#!/usr/bin/env python
# -*- coding: utf-8; py-indent-offset:4 -*-

from typing import NoReturn
import pandas
import numpy
from TradeTide.strategy import Strategy
from TradeTide.plottings import PlotTrade
from TradeTide.tools import percent_to_float
from TradeTide.position import Position


class BackTester():
    """
    A class for backtesting forex trading strategies.

    The ForexBacktester takes a trading strategy, applies it to historical forex data, and simulates the execution
    of trades based on the signals generated by the strategy. It tracks the performance of these trades over time,
    allowing for the evaluation of the strategy's effectiveness.
    """

    def __init__(self, market: pandas.DataFrame, strategy: Strategy):
        """
        Initializes a new instance of the BackTester class with specified market data and trading strategy.

        The BackTester class is designed to simulate trading activity using historical market data and a predefined trading
        strategy. It sets up the environment for backtesting by associating the given market data and strategy with the instance,
        preparing it to execute the backtest through subsequent methods.

        Parameters:
            market (pandas.DataFrame): The historical market data to be used for backtesting. This DataFrame should include
                                       columns relevant to the trading strategy, such as 'date', 'open', 'high', 'low', 'close',
                                       and optionally 'volume', among others.
            strategy (Strategy): An instance of a trading strategy derived from the Strategy class. This strategy should
                                     implement methods for generating trading signals based on the provided market data.

        Attributes:
            market_dataframe (pandas.DataFrame): Stores the provided market data for use in backtesting.
            strategy (Strategy): The trading strategy to be backtested.
            portfolio (pandas.DataFrame or None): Initialized as None, this attribute is intended to store the results of the
                                                   backtest, including the performance of the trading strategy over time. It will
                                                   be populated and updated during the backtesting process.

        Note:
            The 'market_dataframe' must be pre-processed if necessary before passing to this initializer to ensure compatibility
            with the 'strategy'. The 'strategy' instance must be properly configured with any required parameters prior to
            initialization of the BackTester.
        """
        self.market = market
        self.strategy = strategy
        self.portfolio = None

    def signals_to_positions(self) -> NoReturn:
        """
        Transforms trading signals into positions by interpreting changes in the signals.

        This method updates positions based on the following rules:
        - A positive change in the signal (e.g., from 0 to 1) indicates entering a long position.
        - A negative change in the signal (e.g., from 1 to 0 or 1 to -1) indicates exiting a long position or entering a short position.
        - Continuous signals (no change) imply holding the current position.
        - Direct reversals (e.g., from -1 to 1) are allowed and indicate switching positions.

        The 'positions' column in the portfolio DataFrame is updated to reflect the current trading position.
        """
        # Copy signals from the strategy to the portfolio DataFrame
        self.portfolio['signal'] = self.strategy.signal

        # Calculate the difference to detect changes in the signal
        signal_changes = self.portfolio['signal'].diff()

        # Determine positions: 1 for long, -1 for short, 0 for no position
        self.portfolio['positions'] = numpy.select(
            [
                signal_changes > 0,  # Condition for entering a long position
                signal_changes < 0,  # Condition for entering a short position or exiting
            ],
            [
                1,  # Value for entering a long position
                numpy.where(self.portfolio['signal'] == -1, -1, 0)  # Enter short position if signal is -1, else exit
            ],
            default=self.portfolio['signal']  # Default to the current signal, allowing for direct reversals and continuous holding
        )

        # Forward fill to maintain positions until the next change
        self.portfolio['positions'].ffill(inplace=True)

        # Fill initial NaN values with 0 (no position at start)
        self.portfolio['positions'].fillna(0, inplace=True)

    def _signals_to_positions(self):
        """
        Transforms trading signals into positions by interpreting changes in the signals.

        This method updates positions based on the following rules:
        - A positive change in the signal (e.g., from 0 to 1) indicates entering a long position.
        - A negative change in the signal (e.g., from 1 to 0 or 1 to -1) indicates exiting a long position or entering a short position.
        - Continuous signals (no change) imply holding the current position.
        - Direct reversals (e.g., from -1 to 1) are allowed and indicate switching positions.

        The 'positions' column in the portfolio DataFrame is updated to reflect the current trading position.
        """
        # Copy signals from the strategy to the portfolio DataFrame
        self.portfolio['signal'] = self.strategy.signal

        # Calculate the difference to detect changes in the signal
        signal_changes = self.portfolio['signal'].diff()

        # Initialize positions based on signal changes
        self.portfolio['positions'] = 0  # Default to no position

        # Interpret signal changes to determine positions
        for i in range(1, len(signal_changes)):
            if signal_changes.iloc[i] > 0:
                self.portfolio['positions'].iloc[i] = 1  # Enter long position
            elif signal_changes.iloc[i] < 0:
                if self.portfolio['signal'].iloc[i] == -1:
                    self.portfolio['positions'].iloc[i] = -1  # Enter short position
                else:
                    self.portfolio['positions'].iloc[i] = 0  # Exit position
            else:
                # Carry forward the position from the previous period
                self.portfolio['positions'].iloc[i] = self.portfolio['positions'].iloc[i - 1]

        # Handle the initial position based on the initial signal
        self.portfolio.at[self.portfolio.index[0], 'positions'] = self.portfolio['signal'].iloc[0]

    def back_test(
            self,
            stop_loss: float | str = '0.1%',
            take_profit: float | str = '0.1%',
            initial_capital: float = 100_000,
            spread: float = 0.1,
            return_extra_data: bool = False,
            max_cap_per_trade: float = 1_000) -> pandas.DataFrame:
        """
        Executes a backtest of the trading strategy using historical market data, with customizable trading parameters.

        The backtest simulates trading activity based on signals generated by the strategy, adjusting for specified stop loss, take profit,
        and other trading parameters. It calculates the resulting portfolio value over time, taking into account transaction costs and
        capital limitations per trade.

        Parameters:
            stop_loss (float | str, optional): The stop loss threshold, specified as a percentage (e.g., '1%') or a float. Default is '0.1%'.
            take_profit (float | str, optional): The take profit threshold, specified as a percentage (e.g., '1%') or a float. Default is '0.1%'.
            initial_capital (float, optional): The initial capital available for trading. Default is 100,000.
            spread (float, optional): The spread between buy and sell prices as a percentage of the price. Default is 0.01 (1%).
            return_extra_data (bool, optional): If True, the method returns additional data related to the backtest. Default is False.
            max_cap_per_trade (float, optional): The maximum capital allocated per trade. Default is 1,000.

        Returns:
            pandas.DataFrame: A DataFrame representing the portfolio's performance over time. If `return_extra_data` is True, it also
                              returns a DataFrame containing additional backtest-related data.

        The portfolio DataFrame contains columns for dates, trading signals, position changes, and other metrics relevant to evaluating
        the strategy's performance. If `return_extra_data` is True, the additional DataFrame includes detailed information about each trade
        and market conditions at the time of trading.
        """
        stop_loss = percent_to_float(stop_loss)
        take_profit = percent_to_float(take_profit)

        self.initial_capital = initial_capital

        self.manage_positions(
            market=self.market,
            spread=spread,
            stop_loss=stop_loss,
            take_profit=take_profit,
            max_cap_per_trade=max_cap_per_trade
        )

        self.portfolio = pandas.DataFrame(index=self.market.index)
        self.portfolio['units'] = 0.
        self.portfolio['holdings_value'] = 0.
        self.portfolio['holding'] = 0.
        self.portfolio['cash'] = float(initial_capital)
        self.portfolio['positions'] = 0.

        # Calculate cumulative holdings and cash, considering the units bought and the entry price
        for position in self.position_list:
            position.add_units_to_dataframe(self.portfolio)
            position.add_holding_value_to_dataframe(self.portfolio)
            position.add_holding_to_dataframe(self.portfolio)
            position.update_cash(self.portfolio)

        # # Total portfolio value and percentage returns
        self.portfolio['total'] = self.portfolio['cash'] + self.portfolio['holdings_value']
        self.portfolio['returns'] = self.portfolio['total'].ffill().pct_change()

        return self.portfolio

    def manage_positions(
            self,
            market: pandas.DataFrame,
            spread: float,
            stop_loss: float,
            take_profit: float,
            max_cap_per_trade: float) -> NoReturn:
        """
        Manages the opening and closing of trading positions based on stop loss and take profit thresholds, adjusted for spread.

        This method updates the portfolio DataFrame to include entry prices for new positions (adjusted for spread), and calculates
        stop loss and take profit price levels for each open position. It then checks market data to determine if these levels are
        breached, indicating whether a position should be closed due to stop loss or take profit conditions being met.

        Parameters:
            market (pandas.DataFrame): The DataFrame containing historical market data with 'close', 'low', and 'high' price columns.
            spread (float): The spread applied to the entry price of a new position, representing the transaction cost.
            stop_loss (float): The stop loss threshold, expressed as a decimal (e.g., 0.1 for 10%). Positions are closed if the market
                               price drops below this threshold relative to the entry price.
            take_profit (float): The take profit threshold, expressed as a decimal (e.g., 0.1 for 10%). Positions are closed if the market
                                 price rises above this threshold relative to the entry price.

        Updates:
            The portfolio DataFrame is updated in-place to include the following columns:
            - 'opened_positions': Tracks newly opened positions.
            - 'entry_price': The entry price for each position, adjusted for the spread.
            - 'stop_loss_price': The price level at which a stop loss would be triggered.
            - 'take_profit_price': The price level at which a take profit would be triggered.
            - 'stop_loss_triggered': A boolean flag indicating if the stop loss condition has been met.
            - 'take_profit_triggered': A boolean flag indicating if the take profit condition has been met.
            - 'close_positions': A boolean flag indicating if a position should be closed due to stop loss or take profit conditions.

        Note:
            This method assumes the 'positions' column in the portfolio DataFrame tracks the current open positions, where a value of
            1 indicates a new buy position. The method modifies the portfolio DataFrame in-place and does not return a value.
        """
        # Extract signals and identify where new positions should be opened
        signals = self.strategy.data['signal']
        new_positions = signals.diff().fillna(0) != 0

        # Initialize or clear the list to store Position objects
        self.position_list = []

        # Iterate over signals and open new positions where indicated
        for date, signal in signals[new_positions].items():
            if signal != 0:  # Check if the signal indicates a new position (non-zero)
                entry_price = self.market.loc[date, 'close'] + spread
                units = numpy.floor((max_cap_per_trade - spread) / entry_price)

                position = Position(
                    start_date=date,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    market=market,
                    units=units,
                    entry_price=entry_price,
                    type='long' if signal == +1 else 'short'
                )
                self.position_list.append(position)

    def plot(self, **kwargs) -> NoReturn:
        """
        Generates a visual representation of the backtest results using the PlotTrade class.

        This method constructs a figure that includes plots for market data, trading signals, and portfolio metrics,
        providing a comprehensive overview of the trading strategy's performance over the backtesting period.

        The figure is constructed and displayed immediately, utilizing the market data, portfolio results, and the
        strategy instance associated with this BackTester.

        Note:
            The method assumes that the backtest has been run and the `portfolio` attribute of the BackTester class
            has been populated with trading data and results.
        """
        plot = PlotTrade(
            back_tester=self,
            market=self.market,
            portfolio=self.portfolio,
            strategy=self.strategy,
        )

        plot.construct_figure(**kwargs)

    def get_final_portfolio_value(self) -> float:
        """
        Retrieves the final total value of the portfolio at the end of the backtesting period.

        This method calculates the final value of the portfolio, considering all open and closed positions, and prints
        this value to the console. It is a useful metric for assessing the absolute performance of the trading strategy.

        Returns:
            float: The final total value of the portfolio, represented as a monetary amount.

        Note:
            This method should be called after completing the backtest to ensure the portfolio contains the final trading results.
        """
        final_portfolio_value = self.portfolio['total'].iloc[-1]

        print(f"Final Portfolio Value: ${final_portfolio_value:.2f}")

        return final_portfolio_value

    def calculate_performance_metrics(self) -> NoReturn:
        """
        Calculates and displays key performance metrics for the trading strategy based on the backtest results.

        This method computes several important metrics, including total return, annualized return, maximum drawdown,
        Sharpe ratio, and the win-loss ratio. These metrics provide a quantitative evaluation of the strategy's effectiveness
        and risk characteristics over the backtesting period.

        The calculated metrics are printed to the console for review and analysis.

        Preconditions:
            - The backtest must have been executed, and the `portfolio` attribute should contain the trading results.
            - The `initial_capital` attribute must be set to the initial capital used in the backtest.

        Note:
            If the portfolio is not yet populated (i.e., the backtest has not been run), the method will print a message
            indicating that the backtest should be executed first.
        """
        if self.portfolio is None:
            print("Backtest the strategy first before calculating performance metrics.")
            return

        # Total Return
        total_return = (self.portfolio['total'].iloc[-1] / self.initial_capital) - 1

        # Annualized Return
        trading_days = len(self.portfolio)
        annualized_return = ((1 + total_return) ** (365.0 / trading_days)) - 1

        # Maximum Drawdown
        rolling_max = self.portfolio['total'].cummax()
        drawdown = self.portfolio['total'] / rolling_max - 1.0
        max_drawdown = drawdown.min()

        # Sharpe Ratio (Assuming risk-free rate is 0 for simplicity)
        daily_returns = self.portfolio['returns']
        sharpe_ratio = daily_returns.mean() / daily_returns.std() * numpy.sqrt(252)

        # Win-Loss Ratio
        wins = len(self.portfolio[self.portfolio['returns'] > 0])
        losses = len(self.portfolio[self.portfolio['returns'] < 0])
        win_loss_ratio = wins / losses if losses != 0 else numpy.inf

        # Print the metrics
        print(f"Total Return: {total_return * 100:.2f}%")
        print(f"Annualized Return: {annualized_return * 100:.2f}%")
        print(f"Maximum Drawdown: {max_drawdown * 100:.2f}%")
        print(f"Sharpe Ratio: {sharpe_ratio:.2f}")
        print(f"Win-Loss Ratio: {win_loss_ratio:.2f}")

# -
