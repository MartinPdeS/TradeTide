import matplotlib.pyplot as plt
import pandas
import numpy
from TradeTide.strategy import Strategy


class BackTester():
    """
    A class for backtesting forex trading strategies.

    The ForexBacktester takes a trading strategy, applies it to historical forex data, and simulates the execution
    of trades based on the signals generated by the strategy. It tracks the performance of these trades over time,
    allowing for the evaluation of the strategy's effectiveness.
    """

    def __init__(self, market: pandas.DataFrame, strategy: Strategy):
        """
        Initializes the ForexBacktester with a trading strategy and backtesting parameters.
        """
        self.market_dataframe = market
        self.strategy = strategy
        self.portfolio = None

    @property
    def values_0(self):
        return self.market_dataframe[self.metric_0.__repr__()]

    @property
    def values_1(self):
        return self.market_dataframe[self.metric_1.__repr__()]

    def manage_positions(self, market: pandas.DataFrame, spread: float, stop_loss: float, take_profit: float) -> None:
        """
        Manages open positions based on stop-loss, take-profit, and spread.

        :param      spread:  The spread
        :type       spread:  float

        :returns:   { description_of_the_return_value }
        :rtype:     None
        """
        portfolio = self.portfolio
        # Adjust for spread at entry
        portfolio['opened_positions'] = portfolio['positions']
        portfolio['entry_price'] = market['close'].where(portfolio['positions'] == 1) + spread  # maybe + spread

        # Forward fill entry prices for the holding period
        portfolio['entry_price'] = portfolio['entry_price'].ffill()

        # Calculate stop-loss and take-profit prices
        portfolio['stop_loss_price'] = portfolio['entry_price'] * (1 - stop_loss)
        portfolio['take_profit_price'] = portfolio['entry_price'] * (1 + take_profit)

        # Check if stop-loss or take-profit were triggered
        portfolio['stop_loss_triggered'] = market['low'] < portfolio['stop_loss_price']
        portfolio['take_profit_triggered'] = market['high'] > portfolio['take_profit_price']

        # Close positions where stop-loss or take-profit conditions are met
        portfolio['close_positions'] = portfolio['stop_loss_triggered'] | portfolio['take_profit_triggered']
        portfolio.loc[portfolio['close_positions'], 'positions'] = 0

    def calculate_units_and_portfolio(self, initial_capital: float, spread: float, max_cap_per_trade: float, market: pandas.DataFrame):
        """
        Calculates the number of units for each trade and updates the portfolio.
        """
        portfolio = self.portfolio

        # Calculate the number of units that can be bought with the max capital per trade
        portfolio['units'] = numpy.floor((max_cap_per_trade - spread) / portfolio['entry_price'])

        portfolio['holdings'] = (portfolio['units'] * market['close']).cumsum()
        portfolio['cash'] = initial_capital - (portfolio['units'] * portfolio['entry_price']).cumsum()
        portfolio['total'] = portfolio['cash'] + portfolio['holdings']
        portfolio['returns'] = portfolio['total'].pct_change()

    def back_test(
            self,
            stop_loss: float = 0.01,
            take_profit: float = 0.01,
            buy_unit: float = 1_000,
            initial_capital: float = 100_000,
            spread: float = 0.01,
            return_extra_data: bool = False,
            max_cap_per_trade: float = 1_000) -> pandas.DataFrame:
        """
        Run the back tests on the data

        :param      stop_loss:          The stop loss threshold [default is 1%]
        :type       stop_loss:          float
        :param      take_profit:        The take profit threshold [default is 1%]
        :type       take_profit:        float
        :param      buy_unit:           The buy unit
        :type       buy_unit:           float
        :param      initial_capital:    The initial capital
        :type       initial_capital:    float
        :param      return_extra_data:  If true returns some extra data on the computation as a dataframe
        :type       return_extra_data:  bool

        :returns:   The computed portfolio
        :rtype:     pandas.DataFrame
        """
        self.initial_capital = initial_capital
        market = self.market_dataframe.copy()

        # Initialize the portfolio DataFrame
        portfolio = self.portfolio = pandas.DataFrame(index=market.index)
        portfolio['date'] = market['date']

        portfolio['signal'] = self.strategy.signal

        portfolio['positions'] = portfolio['signal'].diff()

        self.manage_positions(
            market=market,
            spread=spread,
            stop_loss=stop_loss,
            take_profit=take_profit
        )

        self.calculate_units_and_portfolio(
            market=market,
            initial_capital=initial_capital,
            spread=spread,
            max_cap_per_trade=max_cap_per_trade
        )

        self.data = market

        if return_extra_data:
            return self.portfolio, market

        return self.portfolio

    def plot(
            self,
            show_stop_loss: bool = False,
            show_take_win: bool = False,
            show_holdings: bool = False,
            show_totals: bool = False,
            show_cash: bool = False) -> None:

        portfolio = self.portfolio

        ax = portfolio.plot.scatter(
            x='date',
            y='signal',
            figsize=(12, 4),
            label='signal',
            color='C0'
        )

        ax_right = ax.twinx()

        if show_stop_loss:
            portfolio['stop_loss_triggered'] = portfolio['stop_loss_triggered'].astype(float)

            portfolio.plot.scatter(
                ax=ax,
                x='date',
                y='stop_loss_triggered',
                label='stop-loss triger',
                color='red',
                marker=7,

            )

        if show_take_win:
            portfolio['take_profit_triggered'] = portfolio['take_profit_triggered'].astype(float)

            portfolio.plot.scatter(
                ax=ax,
                x='date',
                y='take_profit_triggered',
                label='take profit triger',
                color='green',
                marker=6,
            )

        if show_holdings:
            self.portfolio.plot(
                x='date',
                y='holdings',
                linewidth=2,
                ax=ax_right
            )

        if show_totals:
            self.portfolio.plot(
                x='date',
                y='total',
                linewidth=2,
                ax=ax_right
            )

        if show_cash:
            self.portfolio.plot(
                x='date',
                y='cash',
                linewidth=2,
                ax=ax_right
            )

        ax.legend(loc=2)
        ax_right.legend(loc=1)

        plt.show()

    def get_final_portfolio_value(self) -> float:
        """
        Calculates and prints the final value of the portfolio.
        """
        final_portfolio_value = self.portfolio['total'].iloc[-1]
        print(f"Final Portfolio Value: ${final_portfolio_value:.2f}")

        return final_portfolio_value

    def calculate_performance_metrics(self):
        """
        Calculates and prints key performance metrics of the trading strategy based on the backtest results.
        """
        if self.portfolio is None:
            print("Backtest the strategy first before calculating performance metrics.")
            return

        # Total Return
        total_return = (self.portfolio['total'].iloc[-1] / self.initial_capital) - 1

        # Annualized Return
        trading_days = len(self.portfolio)
        annualized_return = ((1 + total_return) ** (365.0 / trading_days)) - 1

        # Maximum Drawdown
        rolling_max = self.portfolio['total'].cummax()
        drawdown = self.portfolio['total'] / rolling_max - 1.0
        max_drawdown = drawdown.min()

        # Sharpe Ratio (Assuming risk-free rate is 0 for simplicity)
        daily_returns = self.portfolio['returns']
        sharpe_ratio = daily_returns.mean() / daily_returns.std() * numpy.sqrt(252)

        # Win-Loss Ratio
        wins = len(self.portfolio[self.portfolio['returns'] > 0])
        losses = len(self.portfolio[self.portfolio['returns'] < 0])
        win_loss_ratio = wins / losses if losses != 0 else numpy.inf

        # Print the metrics
        print(f"Total Return: {total_return * 100:.2f}%")
        print(f"Annualized Return: {annualized_return * 100:.2f}%")
        print(f"Maximum Drawdown: {max_drawdown * 100:.2f}%")
        print(f"Sharpe Ratio: {sharpe_ratio:.2f}")
        print(f"Win-Loss Ratio: {win_loss_ratio:.2f}")

# -
