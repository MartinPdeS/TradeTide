import pandas
import numpy
from TradeTide.strategy import Strategy
from TradeTide.plottings import plot_trading_strategy
from TradeTide.tools import percent_to_float


class BackTester():
    """
    A class for backtesting forex trading strategies.

    The ForexBacktester takes a trading strategy, applies it to historical forex data, and simulates the execution
    of trades based on the signals generated by the strategy. It tracks the performance of these trades over time,
    allowing for the evaluation of the strategy's effectiveness.
    """

    def __init__(self, market: pandas.DataFrame, strategy: Strategy):
        """
        Initializes the ForexBacktester with a trading strategy and backtesting parameters.
        """
        self.market_dataframe = market
        self.strategy = strategy
        self.portfolio = None

    def manage_positions(self, market: pandas.DataFrame, spread: float, stop_loss: float, take_profit: float) -> None:
        """
        Manages open positions based on specified spread, stop loss, and take profit parameters.

        :param      spread:  The spread
        :type       spread:  float

        :returns:   No return
        :rtype:     None
        """
        # Aliasing portfolio
        portfolio = self.portfolio

        # Initialize 'opened_positions' to track the status of new trades
        portfolio['opened_positions'] = portfolio['positions']

        # Entry price includes the spread for buy positions
        portfolio['entry_price'] = market['close'].where(portfolio['positions'] == 1) + spread  # maybe + spread

        # Forward fill entry prices for the holding period
        portfolio['entry_price'] = portfolio['entry_price'].ffill()

        # Calculate stop-loss and take-profit prices
        portfolio['stop_loss_price'] = portfolio['entry_price'] * (1 - stop_loss)
        portfolio['take_profit_price'] = portfolio['entry_price'] * (1 + take_profit)

        # Check if stop-loss or take-profit were triggered
        portfolio['stop_loss_triggered'] = market['low'] < portfolio['stop_loss_price']
        portfolio['take_profit_triggered'] = market['high'] > portfolio['take_profit_price']

        # Close positions where stop-loss or take-profit conditions are met
        portfolio['close_positions'] = portfolio['stop_loss_triggered'] | portfolio['take_profit_triggered']
        portfolio.loc[portfolio['close_positions'], 'positions'] = 0

    def calculate_units_and_portfolio(
            self,
            market: pandas.DataFrame,
            initial_capital: float,
            spread: float,
            max_cap_per_trade: float):
        """
        Calculates the number of units for each trade and updates the portfolio.

        :param      market:             DataFrame containing the historical market data.
        :type       market:             pandas.DataFrame
        :param      initial_capital:    The initial capital
        :type       initial_capital:    float
        :param      spread:             The spread value from the broker
        :type       spread:             float
        :param      max_cap_per_trade:  The maximum capability per trade
        :type       max_cap_per_trade:  float
        """
        # Aliasing portfolio
        portfolio = self.portfolio

        # Determine the number of units that can be bought with the available capital per trade
        portfolio['units'] = numpy.floor((max_cap_per_trade - spread) / portfolio['entry_price'])

        # Calculate cumulative holdings and cash, considering the units bought and the entry price
        portfolio['holdings'] = (portfolio['units'] * market['close']).cumsum()
        portfolio['cash'] = initial_capital - (portfolio['units'] * portfolio['entry_price']).cumsum()

        # Total portfolio value and percentage returns
        portfolio['total'] = portfolio['cash'] + portfolio['holdings']
        portfolio['returns'] = portfolio['total'].ffill().pct_change()

    def back_test(
            self,
            stop_loss: float = 0.01,
            take_profit: float = 0.01,
            buy_unit: float = 1_000,
            initial_capital: float = 100_000,
            spread: float = 0.01,
            return_extra_data: bool = False,
            max_cap_per_trade: float = 1_000) -> pandas.DataFrame:
        """
        Run the back tests on the data

        :param      stop_loss:          The stop loss threshold [default is 1%]
        :type       stop_loss:          float
        :param      take_profit:        The take profit threshold [default is 1%]
        :type       take_profit:        float
        :param      buy_unit:           The buy unit
        :type       buy_unit:           float
        :param      initial_capital:    The initial capital
        :type       initial_capital:    float
        :param      return_extra_data:  If true returns some extra data on the computation as a dataframe
        :type       return_extra_data:  bool

        :returns:   The computed portfolio
        :rtype:     pandas.DataFrame
        """
        stop_loss = percent_to_float(stop_loss)
        take_profit = percent_to_float(take_profit)

        self.initial_capital = initial_capital
        market = self.market_dataframe.copy()

        # Initialize the portfolio DataFrame
        portfolio = self.portfolio = pandas.DataFrame(index=market.index)
        portfolio['date'] = market['date']

        portfolio['signal'] = self.strategy.signal

        portfolio['positions'] = portfolio['signal'].diff()

        portfolio.at[portfolio.index[0], 'positions'] = 0

        self.manage_positions(
            market=market,
            spread=spread,
            stop_loss=stop_loss,
            take_profit=take_profit
        )

        self.calculate_units_and_portfolio(
            market=market,
            initial_capital=initial_capital,
            spread=spread,
            max_cap_per_trade=max_cap_per_trade
        )

        self.data = market

        if return_extra_data:
            return self.portfolio, market

        return self.portfolio

    def plot(self) -> None:
        return plot_trading_strategy(
            market=self.market_dataframe,
            portfolio=self.portfolio,
            strategy=self.strategy,
        )

    def get_final_portfolio_value(self) -> float:
        """
        Calculates and prints the final value of the portfolio.
        """
        final_portfolio_value = self.portfolio['total'].iloc[-1]
        print(f"Final Portfolio Value: ${final_portfolio_value:.2f}")

        return final_portfolio_value

    def calculate_performance_metrics(self):
        """
        Calculates and prints key performance metrics of the trading strategy based on the backtest results.
        """
        if self.portfolio is None:
            print("Backtest the strategy first before calculating performance metrics.")
            return

        # Total Return
        total_return = (self.portfolio['total'].iloc[-1] / self.initial_capital) - 1

        # Annualized Return
        trading_days = len(self.portfolio)
        annualized_return = ((1 + total_return) ** (365.0 / trading_days)) - 1

        # Maximum Drawdown
        rolling_max = self.portfolio['total'].cummax()
        drawdown = self.portfolio['total'] / rolling_max - 1.0
        max_drawdown = drawdown.min()

        # Sharpe Ratio (Assuming risk-free rate is 0 for simplicity)
        daily_returns = self.portfolio['returns']
        sharpe_ratio = daily_returns.mean() / daily_returns.std() * numpy.sqrt(252)

        # Win-Loss Ratio
        wins = len(self.portfolio[self.portfolio['returns'] > 0])
        losses = len(self.portfolio[self.portfolio['returns'] < 0])
        win_loss_ratio = wins / losses if losses != 0 else numpy.inf

        # Print the metrics
        print(f"Total Return: {total_return * 100:.2f}%")
        print(f"Annualized Return: {annualized_return * 100:.2f}%")
        print(f"Maximum Drawdown: {max_drawdown * 100:.2f}%")
        print(f"Sharpe Ratio: {sharpe_ratio:.2f}")
        print(f"Win-Loss Ratio: {win_loss_ratio:.2f}")

# -
