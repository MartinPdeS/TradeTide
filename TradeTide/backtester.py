#!/usr/bin/env python
# -*- coding: utf-8; py-indent-offset:4 -*-

from typing import NoReturn
import pandas
import numpy
from TradeTide.strategy import Strategy
from TradeTide.plottings import PlotTrade
from TradeTide.capital_managment import LimitedCapital, UnlimitedCapital

from tabulate import tabulate


class BackTester():
    """
    A class for backtesting forex trading strategies.

    The ForexBacktester takes a trading strategy, applies it to historical forex data, and simulates the execution
    of trades based on the signals generated by the strategy. It tracks the performance of these trades over time,
    allowing for the evaluation of the strategy's effectiveness.
    """

    def __init__(self, market: pandas.DataFrame, strategy: Strategy):
        """
        Initializes a new instance of the BackTester class with specified market data and trading strategy.

        The BackTester class is designed to simulate trading activity using historical market data and a predefined trading
        strategy. It sets up the environment for backtesting by associating the given market data and strategy with the instance,
        preparing it to execute the backtest through subsequent methods.

        Parameters:
            market (pandas.DataFrame): The historical market data to be used for backtesting. This DataFrame should include
                                       columns relevant to the trading strategy, such as 'date', 'open', 'high', 'low', 'close',
                                       and optionally 'volume', among others.
            strategy (Strategy): An instance of a trading strategy derived from the Strategy class. This strategy should
                                     implement methods for generating trading signals based on the provided market data.

        Attributes:
            market_dataframe (pandas.DataFrame): Stores the provided market data for use in backtesting.
            strategy (Strategy): The trading strategy to be backtested.
            portfolio (pandas.DataFrame or None): Initialized as None, this attribute is intended to store the results of the
                                                   backtest, including the performance of the trading strategy over time. It will
                                                   be populated and updated during the backtesting process.

        Note:
            The 'market_dataframe' must be pre-processed if necessary before passing to this initializer to ensure compatibility
            with the 'strategy'. The 'strategy' instance must be properly configured with any required parameters prior to
            initialization of the BackTester.
        """
        self.market = market
        self.strategy = strategy
        self.strategy.generate_signal(self.market)
        self.portfolio = None

    def signals_to_positions(self) -> NoReturn:
        """
        Transforms trading signals into positions by interpreting changes in the signals.

        This method updates positions based on the following rules:
        - A positive change in the signal (e.g., from 0 to 1) indicates entering a long position.
        - A negative change in the signal (e.g., from 1 to 0 or 1 to -1) indicates exiting a long position or entering a short position.
        - Continuous signals (no change) imply holding the current position.
        - Direct reversals (e.g., from -1 to 1) are allowed and indicate switching positions.

        The 'positions' column in the portfolio DataFrame is updated to reflect the current trading position.
        """
        # Calculate the difference to detect changes in the signal
        signal_changes = self.strategy.signal.diff()

        # Determine positions: 1 for long, -1 for short, 0 for no position
        self.portfolio['positions'] = numpy.select(
            [
                signal_changes > 0,  # Condition for entering a long position
                signal_changes < 0,  # Condition for entering a short position or exiting
            ],
            [
                1,  # Value for entering a long position
                numpy.where(self.strategy.signal == -1, -1, 0)  # Enter short position if signal is -1, else exit
            ],
            default=self.strategy.signal  # Default to the current signal, allowing for direct reversals and continuous holding
        )

        # Forward fill to maintain positions until the next change
        self.portfolio['positions'].ffill(inplace=True)

        # Fill initial NaN values with 0 (no position at start)
        self.portfolio['positions'].fillna(0, inplace=True)

    def backtest(self, capital_managment: LimitedCapital | UnlimitedCapital) -> pandas.DataFrame:
        """
        Conducts a backtest on a trading strategy using historical market data, applying either a limited or unlimited
        capital position strategy.

        This method simulates trading operations based on the strategy's signals within the constraints of the specified
        position strategy (either LimitedCapital or UnlimitedCapital). It takes into account the initial capital, transaction
        costs, and the capital allocation per trade, to compute the performance of the trading portfolio over time.

        Parameters:
            capital_managment (LimitedCapital | UnlimitedCapital): An instance of a position strategy, which determines
            the trading behavior based on capital limitations. The strategy must be one of the following:
                - LimitedCapital: A strategy that enforces a maximum limit on the capital allocated per trade.
                - UnlimitedCapital: A strategy with no limit on the capital allocation per trade, implying the availability
                  of unlimited capital for trading.

        Returns:
            pandas.DataFrame: A DataFrame that chronicles the performance of the trading portfolio over the course of the
            backtest. This includes columns for the date, current holdings (units), cash balance, and positions (both long
            and short), reflecting changes in the portfolio's value over time.

        The method initializes the portfolio with the given initial capital and iterates through market data to apply the
        trading strategy. Trades are executed based on the strategy's signals, adjusting the portfolio's positions and cash
        balance accordingly. The final DataFrame provides a detailed account of the portfolio's performance, facilitating
        analysis of the strategy's effectiveness.

        Note:
            - The specific implementation of position management and trade execution is dependent on the `position_strategy`
              parameter, which must be provided when calling this method.
            - This method does not return additional data frames with extra backtest-related data. For detailed trade or
              market condition analysis, modifications to the method or strategy implementation may be required.
        """
        self.capital_managment = capital_managment

        self.portfolio = pandas.DataFrame(
            0.0,
            index=self.market.index,
            columns=['date', 'units', 'holdings', 'short_positions', 'long_positions', 'cash']
        )
        self.portfolio['date'] = self.market['date']
        self.portfolio['cash'] = float(capital_managment.initial_capital)

        capital_managment.manage(
            backtester=self,
            market=self.market,
        )

        self.generate_portfolio()

        return self.portfolio

    def generate_portfolio(self) -> NoReturn:
        # Calculate cumulative holdings and cash, considering the units bought and the entry price
        for position in self.position_list:
            position.update_portfolio_dataframe(dataframe=self.portfolio)

        # # Total portfolio value and percentage returns
        self.portfolio['total'] = self.portfolio['cash'] + self.portfolio['holdings']
        self.portfolio['returns'] = self.portfolio['total'].ffill().pct_change()

    def plot(self, **kwargs) -> NoReturn:
        """
        Generates a visual representation of the backtest results using the PlotTrade class.

        This method constructs a figure that includes plots for market data, trading signals, and portfolio metrics,
        providing a comprehensive overview of the trading strategy's performance over the backtesting period.

        The figure is constructed and displayed immediately, utilizing the market data, portfolio results, and the
        strategy instance associated with this BackTester.

        Note:
            The method assumes that the backtest has been run and the `portfolio` attribute of the BackTester class
            has been populated with trading data and results.
        """
        plot = PlotTrade(
            backtester=self,
            market=self.market,
            portfolio=self.portfolio,
            strategy=self.strategy,
        )

        plot.plot_trading_strategy(**kwargs)

    def get_final_portfolio_value(self) -> float:
        """
        Retrieves the final total value of the portfolio at the end of the backtesting period.

        This method calculates the final value of the portfolio, considering all open and closed positions, and prints
        this value to the console. It is a useful metric for assessing the absolute performance of the trading strategy.

        Returns:
            float: The final total value of the portfolio, represented as a monetary amount.

        Note:
            This method should be called after completing the backtest to ensure the portfolio contains the final trading results.
        """
        final_portfolio_value = self.portfolio['total'].iloc[-1]

        print(f"Final Portfolio Value: ${final_portfolio_value:.2f}")

        return final_portfolio_value

    def calculate_total_return(self) -> float:
        """
        Calculates the total return of the trading strategy.

        Returns:
            float: The total return as a percentage.
        """
        return (self.portfolio['total'].iloc[-1] / self.capital_managment.initial_capital) - 1

    def calculate_annualized_return(self, total_return: float) -> float:
        """
        Calculates the annualized return given the total return.

        Args:
            total_return (float): The total return of the strategy.

        Returns:
            float: The annualized return as a percentage.
        """
        trading_days = (self.market.date.iloc[-1] - self.market.date.iloc[0]).days

        if trading_days == 0:
            return numpy.nan

        return ((1 + total_return) ** (365.0 / trading_days)) - 1

    def calculate_max_drawdown(self) -> float:
        """
        Calculates the maximum drawdown of the portfolio.

        Returns:
            float: The maximum drawdown as a percentage.
        """
        rolling_max = self.portfolio['total'].cummax()
        drawdown = self.portfolio['total'] / rolling_max - 1.0
        return drawdown.min()

    def calculate_sharpe_ratio(self) -> float:
        """
        Calculates the Sharpe ratio, which measures the performance of an investment
        compared to a risk-free asset, after adjusting for its risk.

        Returns:
            float: The Sharpe ratio. A higher value indicates better risk-adjusted return.
        """
        daily_returns = self.portfolio['returns']
        return daily_returns.mean() / daily_returns.std() * numpy.sqrt(252)

    def calculate_win_loss_ratio(self) -> float:
        """
        Calculates the win-loss ratio of the trading positions.

        Returns:
            float: The ratio of wins to losses. A value of numpy.inf indicates no losses.
        """
        wins = sum(1 for pos in self.position_list if pos.is_win == 1)
        losses = sum(1 for pos in self.position_list if pos.is_win == -1)
        return wins / losses if losses != 0 else numpy.inf

    def calculate_equity(self) -> float:
        """
        Calculates the final equity of the portfolio.

        Returns:
            float: The ending equity value.
        """
        return self.portfolio['total'].iloc[-1]

    def calculate_duration(self) -> int:
        """
        Calculates the duration of the backtest in days.

        Returns:
            int: The duration of the backtest.
        """
        return (self.market.date.iloc[-1] - self.market.date.iloc[0]).days

    def calculate_volatility(self) -> float:
        """
        Calculates the volatility of daily returns, which measures the dispersion of returns.

        Returns:
            float: The annualized volatility as a percentage.
        """
        return self.portfolio['returns'].std() * numpy.sqrt(252)

    def calculate_sortino_ratio(self) -> float:
        """
        Calculates the Sortino ratio, similar to the Sharpe ratio but only considers downside volatility,
        which provides a better measure of the risk-adjusted return for asymmetrical return distributions.

        Returns:
            float: The Sortino ratio. A higher value indicates a better return per unit of bad risk taken.
        """
        daily_returns = self.portfolio['returns']
        negative_returns = daily_returns[daily_returns < 0]
        downside_std = numpy.sqrt((negative_returns ** 2).mean()) * numpy.sqrt(252)
        annualized_return = self.calculate_annualized_return(self.calculate_total_return())
        return annualized_return / downside_std if downside_std != 0 else numpy.inf

    def calculate_performance_metrics(self) -> dict:
        """
        Calculates and compiles key performance metrics for the trading strategy.

        This includes total return, annualized return, maximum drawdown, Sharpe ratio, Sortino ratio,
        win-loss ratio, equity, duration, and volatility. These metrics quantify the strategy's
        effectiveness and risk characteristics.

        Returns:
            dict: A dictionary containing all calculated performance metrics.
        """
        if self.portfolio is None:
            print("Backtest the strategy first before calculating performance metrics.")
            return {}

        total_return = self.calculate_total_return()
        annualized_return = self.calculate_annualized_return(total_return)
        max_drawdown = self.calculate_max_drawdown()
        sharpe_ratio = self.calculate_sharpe_ratio()
        sortino_ratio = self.calculate_sortino_ratio()
        win_loss_ratio = self.calculate_win_loss_ratio()
        equity = self.calculate_equity()
        duration = self.calculate_duration()
        volatility = self.calculate_volatility()

        self.performance_dict = {
            "Start Date": self.market.date.iloc[0],
            "Stop Date": self.market.date.iloc[-1],
            "Duration": f"{duration} days",
            "Reward-Risk ratio": self.capital_managment.risk_management.reward_risk_ratio,
            "Returns": f"{total_return * 100:.2f}%",
            "Returns [annualized]": f"{annualized_return * 100:.2f}%",
            "Maximum drawdown": f"{max_drawdown * 100:.2f}%",
            "Sharpe Ratio": f"{sharpe_ratio:.2f}",
            "Sortino Ratio": f"{sortino_ratio:.2f}",
            "Number of Trades": f"{len(self.position_list)}",
            "Win-Loss Ratio": f"{win_loss_ratio:.2f}",
            "Equity": f"${equity:,.2f}",
            "Volatility": f"{volatility * 100:.2f}%"
        }

        return self.performance_dict

    def print_metrics(self) -> NoReturn:

        property_dict = {
            "Property": self.performance_dict.keys(), "value": self.performance_dict.values()
        }

        table = tabulate(
            property_dict,
            headers="keys"
        )
        print(table)


# -
