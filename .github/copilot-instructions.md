# GitHub Copilot Instructions for TradeTide

## Project Overview
TradeTide is a comprehensive Python library for forex trading strategy backtesting and analysis. It provides tools for technical analysis, portfolio simulation, and performance evaluation.

## Architecture
- **Language**: Python 3.11+ with C++ backend (pybind11)
- **Core Components**: Market data handling, technical indicators, trading strategies, portfolio management
- **Build System**: CMake + scikit-build-core
- **Documentation**: Sphinx with gallery examples

## Code Style and Conventions

### Python Code Standards
- Follow PEP 8 style guidelines
- Use type hints for all function parameters and return values
- Maximum line length: No line breaking for length (project-specific rule)
- Use NumPy-style docstrings for all public methods
- Never use emojis in code, comments, or documentation

### Naming Conventions
- Classes: PascalCase (e.g., `MovingAverageCrossing`, `BollingerBands`)
- Functions/methods: snake_case (e.g., `get_trade_signal`, `run_backtest`)
- Constants: UPPER_CASE (e.g., `DEFAULT_WINDOW_SIZE`)
- Private methods: Leading underscore (e.g., `_validate_data`)

### Documentation Standards
- All public classes and methods must have comprehensive NumPy-style docstrings
- Include Parameters, Returns, Raises, Examples, and Notes sections
- Use Sphinx Gallery format for examples with `# %%` cell separators
- Document mathematical formulas using LaTeX notation

## Project Structure
```
TradeTide/
├── TradeTide/                   # Main package
│   ├── cpp/                     # C++ backend implementation
│   ├── binary/                  # Compiled binaries (pybind11)
│   ├── indicators/              # Technical indicators
│   ├── market.py               # Market data handling
│   ├── portfolio.py            # Portfolio management
│   ├── backtester.py           # Backtesting engine
│   └── ...
├── tests/                      # Test suite
├── docs/                       # Documentation
│   └── examples/               # Sphinx gallery examples
└── development/                # Development scripts
```

## Technical Preferences

### Testing
- Use pytest for all tests
- Test files should mirror the module structure (`test_module_name.py`)
- Include fixtures, parametrized tests, and edge cases
- Use descriptive test function names with docstrings
- Test both normal operation and error conditions

### C++ Integration
- Use pybind11 for Python-C++ bindings
- C++ code uses modern C++17/20 features
- Doxygen-style comments for C++ headers
- All C++ classes exposed to Python should have proper docstrings

### Performance
- Use NumPy arrays for numerical computations
- Leverage C++ backend for computationally intensive operations
- Memory-efficient data structures for large datasets
- Profile code when performance is critical

## Domain-Specific Context

### Financial Trading Concepts
- **Market Data**: OHLC (Open, High, Low, Close) price data with bid/ask spreads
- **Technical Indicators**: Mathematical calculations on price data (moving averages, Bollinger Bands, RSI, etc.)
- **Trading Signals**: Buy/sell recommendations generated by strategies
- **Risk Management**: Stop loss, take profit, position sizing
- **Portfolio Metrics**: Returns, Sharpe ratio, drawdown, win rate

### Key Classes and Their Purposes
- `Market`: Handles forex market data loading and manipulation
- `Strategy`: Combines indicators to generate trading signals
- `Portfolio`: Manages positions and calculates performance
- `Backtester`: Automated backtesting engine
- `PositionCollection`: Manages individual trading positions
- `BaseIndicator`: Parent class for all technical indicators

## Development Guidelines

### When Creating New Features
1. Start with comprehensive docstrings and type hints
2. Follow existing patterns from similar classes
3. Add corresponding tests with good coverage
4. Update documentation and examples if needed
5. Consider both Python API and potential C++ backend needs

### Error Handling
- Use specific exception types (ValueError, RuntimeError, etc.)
- Provide clear, actionable error messages
- Validate inputs at public API boundaries
- Handle edge cases gracefully

### Plotting and Visualization
- Use matplotlib with MPSPlots style (`from MPSPlots.styles import mps`)
- Standard figure sizes: (12, 8) for most plots
- Include proper legends, labels, and titles
- Support both show and return figure patterns
- Use consistent color schemes across the project

## Example Patterns

### Class Definition
```python
class NewIndicator(BaseIndicator):
    """
    Brief description of the indicator.

    Parameters
    ----------
    window : timedelta
        Time window for calculation.
    parameter : float
        Description of parameter.

    Attributes
    ----------
    market : Market
        Market data used for calculations.
    """

    def __init__(self, window: timedelta, parameter: float):
        self.window = window
        self.parameter = parameter
```

### Method Documentation
```python
def calculate_signal(self, market: Market) -> np.ndarray:
    """
    Calculate trading signals based on market data.

    Parameters
    ----------
    market : Market
        Market data for signal calculation.

    Returns
    -------
    numpy.ndarray
        Array of trading signals (1=buy, -1=sell, 0=hold).

    Raises
    ------
    ValueError
        If market data is insufficient for calculation.
    """
```

## Common Anti-Patterns to Avoid
- Breaking lines due to length (project uses no line length limit)
- Using emojis anywhere in the codebase
- Inconsistent docstring formats
- Missing type hints
- Hardcoded magic numbers without constants
- Not following the established C++/Python integration patterns

## Testing Patterns
- Use fixtures for common test data
- Parametrize tests for multiple scenarios
- Test edge cases and error conditions
- Include performance tests for critical paths
- Mock external dependencies appropriately

Remember: TradeTide prioritizes clean, professional code with comprehensive documentation and robust testing. The project serves both educational and practical purposes in quantitative finance.
